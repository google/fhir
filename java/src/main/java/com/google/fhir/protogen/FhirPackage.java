//    Copyright 2019 Google LLC
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        https://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package com.google.fhir.protogen;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.io.ByteStreams;
import com.google.fhir.common.JsonFormat;
import com.google.fhir.common.ResourceUtils;
import com.google.fhir.dstu2.StructureDefinitionTransformer;
import com.google.fhir.proto.Annotations.FhirVersion;
import com.google.fhir.proto.PackageInfo;
import com.google.fhir.r4.core.Bundle;
import com.google.fhir.r4.core.CodeSystem;
import com.google.fhir.r4.core.StructureDefinition;
import com.google.fhir.r4.core.ValueSet;
import com.google.protobuf.Message;
import com.google.protobuf.TextFormat;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Optional;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * Struct representing a FHIR Proto package, including defining resources and a PackageInfo proto.
 * This is constructed from a zip file containing these files, as generated by the `fhir_package`
 * rule in protogen.bzl.
 */
public class FhirPackage {
  public final PackageInfo packageInfo;
  public final List<StructureDefinition> structureDefinitions;
  public final List<CodeSystem> codeSystems;
  public final List<ValueSet> valueSets;

  public FhirPackage(
      PackageInfo packageInfo,
      List<StructureDefinition> structureDefinitions,
      List<CodeSystem> codeSystems,
      List<ValueSet> valueSets) {
    this.packageInfo = packageInfo;
    this.structureDefinitions = structureDefinitions;
    this.codeSystems = codeSystems;
    this.valueSets = valueSets;
  }

  public static FhirPackage load(String zipFilePath) throws IOException {
    return load(zipFilePath, FhirVersion.R4);
  }

  public static FhirPackage load(String zipFilePath, FhirVersion fhirVersion) throws IOException {
    List<ValueSet> valueSets = new ArrayList<>();
    List<CodeSystem> codeSystems = new ArrayList<>();
    List<StructureDefinition> structureDefinitions = new ArrayList<>();
    PackageInfo packageInfo = null;

    JsonFormat.Parser parser =
        fhirVersion == FhirVersion.DSTU2 || fhirVersion == fhirVersion.STU3
            ? JsonFormat.getEarlyVersionGeneratorParser()
            : JsonFormat.getParser();
    ZipFile zipFile = new ZipFile(new File(zipFilePath));
    Enumeration<? extends ZipEntry> entries = zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      if (entry.getName().endsWith("package_info.prototxt")) {
        String protoTxt = new String(ByteStreams.toByteArray(zipFile.getInputStream(entry)), UTF_8);
        PackageInfo.Builder infoBuilder = PackageInfo.newBuilder();
        TextFormat.getParser().merge(protoTxt, infoBuilder);
        packageInfo = infoBuilder.build();
        if (packageInfo.getProtoPackage().isEmpty()) {
          throw new IllegalArgumentException(
              "Missing proto_package from PackageInfo in " + zipFilePath);
        }
      }
      if (!entry.getName().endsWith(".json")) {
        continue;
      }
      String json = new String(ByteStreams.toByteArray(zipFile.getInputStream(entry)), UTF_8);
      if (fhirVersion == FhirVersion.DSTU2) {
        json = StructureDefinitionTransformer.transformDstu2ToStu3(json);
      }

      Optional<ValueSet> valueSet = tryParsingAs(json, ValueSet.getDefaultInstance(), parser);
      if (valueSet.isPresent()) {
        valueSets.add(valueSet.get());
        continue;
      }
      Optional<CodeSystem> codeSystem = tryParsingAs(json, CodeSystem.getDefaultInstance(), parser);
      if (codeSystem.isPresent()) {
        codeSystems.add(codeSystem.get());
        continue;
      }
      Optional<StructureDefinition> structureDefinition =
          tryParsingAs(json, StructureDefinition.getDefaultInstance(), parser);
      if (structureDefinition.isPresent()) {
        structureDefinitions.add(structureDefinition.get());
        continue;
      }

      Optional<Bundle> bundle = tryParsingAs(json, Bundle.getDefaultInstance(), parser);
      if (bundle.isPresent()) {
        for (Bundle.Entry bundleEntry : bundle.get().getEntryList()) {
          Message contained = ResourceUtils.getContainedResource(bundleEntry.getResource());
          if (contained instanceof ValueSet) {
            valueSets.add((ValueSet) contained);
          } else if (contained instanceof CodeSystem) {
            codeSystems.add((CodeSystem) contained);
          } else if (contained instanceof StructureDefinition) {
            structureDefinitions.add((StructureDefinition) contained);
          }
        }
      }
    }
    if (packageInfo == null) {
      throw new IllegalArgumentException(
          "No package info file found in "
              + zipFilePath
              + ".  The package info file must end in package_info.prototxt");
    }
    return new FhirPackage(packageInfo, structureDefinitions, codeSystems, valueSets);
  }

  @SuppressWarnings("unchecked")
  private static <T extends Message> Optional<T> tryParsingAs(
      String json, T type, JsonFormat.Parser parser) {
    try {
      Message.Builder typeBuilder = type.newBuilderForType();
      parser.merge(json, typeBuilder);
      return Optional.of((T) typeBuilder.build());
    } catch (IllegalArgumentException e) {
      return Optional.empty();
    }
  }
}
