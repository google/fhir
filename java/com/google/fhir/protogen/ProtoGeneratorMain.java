//    Copyright 2018 Google Inc.
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        https://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

package com.google.fhir.protogen;

import static com.google.common.collect.Streams.stream;
import static java.nio.charset.StandardCharsets.UTF_8;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.ParameterException;
import com.google.common.base.CaseFormat;
import com.google.common.collect.ImmutableList;
import com.google.fhir.common.AnnotationUtils;
import com.google.fhir.common.InvalidFhirException;
import com.google.fhir.proto.Annotations;
import com.google.fhir.proto.PackageInfo;
import com.google.fhir.r4.core.StructureDefinition;
import com.google.fhir.r4.core.StructureDefinitionKindCode;
import com.google.fhir.r4.core.TypeDerivationRuleCode;
import com.google.protobuf.DescriptorProtos.DescriptorProto;
import com.google.protobuf.DescriptorProtos.FileDescriptorProto;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * A class that runs ProtoGenerator on the specified inputs, turning FHIR StructureDefinition files
 * into proto descriptors. Depending on settings, either the descriptors, the .proto file, or both
 * will be emitted.
 */
class ProtoGeneratorMain {

  private final Args args;

  private static final String EXTENSION_STRUCTURE_DEFINITION_URL =
      "http://hl7.org/fhir/StructureDefinition/Extension";

  private static class Args {
    @Parameter(
        names = {"--output_directory"},
        description = "Directory where generated output will be saved")
    private String outputDirectory = ".";

    @Parameter(
        names = {"--directory_in_source"},
        description =
            "The directory in the source tree that the proto files will be located. "
                + "This allows for intra-package imports, like codes and extensions.")
    private String directoryInSource = null;

    @Parameter(
        names = {"--filter"},
        description =
            "Filter for types of definitions in input package to use.  If set, must be one of"
                + " resource, profile, extension, datatype.")
    private String filter = null;

    @Parameter(
        names = {"--sort"},
        description = "If true, will sort messages within a file by message name.")
    private boolean sort = false;

    @Parameter(
        names = {"--r4_core_dep"},
        description =
            "FhirPackage for core R4 Definitions.  See --fhir_definition_dep flag for documentaton"
                + " on format.")
    private String r4CoreDep = null;

    @Parameter(
        names = {"--fhir_definition_dep"},
        description =
            "List of FhirPackages that this package depends on.  These should be zips containing a"
                + " PackageInfo prototxt file, along with resources defined by the package, such"
                + " as the ones generated by the fhir_package rule in protogen.bzl")
    private List<String> fhirDefinitionDepList = new ArrayList<>();

    @Parameter(
        names = {"--additional_import"},
        description = "Non-core FHIR Packages to add.")
    private List<String> additionalImports = new ArrayList<>();

    @Parameter(
        names = {"--output_name"},
        description =
            "Name for output proto files.  If writing a single resource proto file, will write to"
                + " {$output_name.proto}. If splitting resources, will write all resources in"
                + " separate files to {$output_name.zip}. If writing a separate extensions file,"
                + " will output ${output_name}_extensions.proto.")
    private String outputName = "output";

    @Parameter(
        names = {"--edition"},
        description = "proto edition")
    private String edition = "";

    @Parameter(
        names = {"--input_package"},
        description = "Input FHIR package",
        required = true)
    private String inputPackageLocation = null;

    @Parameter(
        names = {"--exclude"},
        description = "Ids of input StructureDefinitions to ignore.")
    private List<String> excludeIds = new ArrayList<>();

    private Set<FhirPackage> getDependencies() throws IOException, InvalidFhirException {
      Set<FhirPackage> packages = new HashSet<>();
      for (String fhirDefinitionDep : fhirDefinitionDepList) {
        packages.add(FhirPackage.load(fhirDefinitionDep));
      }
      return packages;
    }
  }

  ProtoGeneratorMain(Args args) {
    this.args = args;
  }

  void run() throws IOException, InvalidFhirException {
    Set<FhirPackage> fhirPackages = args.getDependencies();

    FhirPackage unfilteredInputPackage = FhirPackage.load(args.inputPackageLocation);
    fhirPackages.add(unfilteredInputPackage);
    FhirPackage inputPackage =
        args.filter == null
            ? unfilteredInputPackage
            : applyFilter(unfilteredInputPackage, args.filter);
    PackageInfo packageInfo = inputPackage.packageInfo;

    if (packageInfo.getProtoPackage().isEmpty()) {
      throw new IllegalArgumentException(
          "package_info must contain at least a proto_package and fhir_version.");
    }

    // Add in core FHIR types (e.g., datatypes and unprofiled resources)
    fhirPackages.add(FhirPackage.load(args.r4CoreDep));

    List<StructureDefinition> inputDefinitions =
        stream(inputPackage.structureDefinitions().iterator())
            .filter(def -> !args.excludeIds.contains(def.getId().getValue()))
            .collect(Collectors.toList());

    // Generate the proto file.
    System.out.println("Generating proto descriptors...");

    ValueSetGenerator valueSetGenerator =
        new ValueSetGenerator(packageInfo, fhirPackages, args.edition);
    ProtoGenerator generator =
        new ProtoGenerator(
            packageInfo,
            args.directoryInSource + "/" + args.outputName + "_codes.proto",
            fhirPackages,
            valueSetGenerator,
            args.edition);
    ProtoFilePrinter printer = new ProtoFilePrinter(packageInfo);

    try (ZipOutputStream zipOutputStream =
        new ZipOutputStream(
            new FileOutputStream(new File(args.outputDirectory, args.outputName + ".zip")))) {
      if (inputPackage != null && args.filter == null) {
        // We're generating a whole input package.  Make sure to add codes if there are any to
        // generate.
        FileDescriptorProto codesFileProto =
            valueSetGenerator.generateCodeSystemAndValueSetsFile(inputPackage);
        if (!codesFileProto.getMessageTypeList().isEmpty()) {
          try {
            zipOutputStream.putNextEntry(new ZipEntry(args.outputName + "_codes.proto"));
            byte[] entryBytes = printer.print(codesFileProto).getBytes(UTF_8);
            zipOutputStream.write(entryBytes, 0, entryBytes.length);
          } finally {
            zipOutputStream.closeEntry();
          }
        }
      }

      switch (packageInfo.getFileSplittingBehavior()) {
        case DEFAULT_SPLITTING_BEHAVIOR:
        case NO_SPLITTING:
          writeWithCombinedExtensionsAndResourcesFile(
              inputDefinitions, generator, printer, packageInfo, zipOutputStream);
          break;
        case SEPARATE_EXTENSIONS:
          writeWithSeparateExtensionsFile(
              inputDefinitions, generator, printer, packageInfo, zipOutputStream);
          break;
        case SPLIT_RESOURCES:
          writeSplitResources(inputDefinitions, generator, printer, packageInfo, zipOutputStream);
          break;
        case UNRECOGNIZED:
          throw new IllegalArgumentException(
              "Unrecognized file splitting behavior: " + packageInfo.getFileSplittingBehavior());
      }
    }
  }

  private static FhirPackage applyFilter(FhirPackage fhirPackage, String type) {
    Predicate<StructureDefinition> isDatatype =
        def ->
            def.getKind().getValue() == StructureDefinitionKindCode.Value.PRIMITIVE_TYPE
                || def.getKind().getValue() == StructureDefinitionKindCode.Value.COMPLEX_TYPE;
    Predicate<StructureDefinition> isResource = def -> isResource(def);
    Predicate<StructureDefinition> isConstraint =
        def -> def.getDerivation().getValue() == TypeDerivationRuleCode.Value.CONSTRAINT;
    Predicate<StructureDefinition> isExtensionProfile =
        isConstraint.and(
            def ->
                def.getBaseDefinition()
                    .getValue()
                    .equals("http://hl7.org/fhir/StructureDefinition/Extension"));
    switch (type) {
      case "datatype":
        return fhirPackage.filterResources(isDatatype.and(isExtensionProfile.negate()));
      case "extension":
        return fhirPackage.filterResources(isExtensionProfile);
      case "resource":
        return fhirPackage.filterResources(isResource.and(isConstraint.negate()));
      case "profile":
        return fhirPackage.filterResources(isResource.and(isConstraint));
      default:
        throw new IllegalArgumentException("Unrecognized filter: " + type);
    }
  }

  private void writeWithCombinedExtensionsAndResourcesFile(
      List<StructureDefinition> definitions,
      ProtoGenerator generator,
      ProtoFilePrinter printer,
      PackageInfo packageInfo,
      ZipOutputStream zipOutputStream)
      throws IOException, InvalidFhirException {
    FileDescriptorProto proto =
        generator.generateFileDescriptor(definitions, args.additionalImports);
    if (packageInfo.getLocalContainedResource()) {
      proto = generator.addContainedResource(proto, proto.getMessageTypeList());
    }
    addZipEntry(args.outputName + ".proto", proto, printer, zipOutputStream);
  }

  private void writeWithSeparateExtensionsFile(
      List<StructureDefinition> definitions,
      ProtoGenerator generator,
      ProtoFilePrinter printer,
      PackageInfo packageInfo,
      ZipOutputStream zipOutputStream)
      throws IOException, InvalidFhirException {
    List<StructureDefinition> extensions = new ArrayList<>();
    List<StructureDefinition> profiles = new ArrayList<>();
    for (StructureDefinition structDef : definitions) {
      if (structDef.getBaseDefinition().getValue().equals(EXTENSION_STRUCTURE_DEFINITION_URL)) {
        extensions.add(structDef);
      } else {
        profiles.add(structDef);
      }
    }
    if (!extensions.isEmpty()) {
      addZipEntry(
          args.outputName + "_extensions.proto",
          generator.generateFileDescriptor(extensions),
          printer,
          zipOutputStream);
      args.additionalImports.add(
          args.directoryInSource + "/" + args.outputName + "_extensions.proto");
    }
    if (!profiles.isEmpty()) {
      FileDescriptorProto mainFileProto =
          generator.generateFileDescriptor(profiles, args.additionalImports);
      if (packageInfo.getLocalContainedResource()) {
        mainFileProto =
            generator.addContainedResource(mainFileProto, mainFileProto.getMessageTypeList());
      }
      addZipEntry(args.outputName + ".proto", mainFileProto, printer, zipOutputStream);
    }
  }

  private void writeSplitResources(
      List<StructureDefinition> definitions,
      ProtoGenerator generator,
      ProtoFilePrinter printer,
      PackageInfo packageInfo,
      ZipOutputStream zipOutputStream)
      throws IOException, InvalidFhirException {
    // Divide into three categories.
    // Extensions and datatypes will be printed into a single aggregate file each,
    // while resources will be printed into one file per resource.
    // Note primititives are include in datatypes here.
    List<StructureDefinition> extensions = new ArrayList<>();
    List<StructureDefinition> datatypes = new ArrayList<>();
    List<StructureDefinition> resources = new ArrayList<>();

    for (StructureDefinition structDef : definitions) {
      StructureDefinitionKindCode.Value kind = structDef.getKind().getValue();
      if (structDef.getBaseDefinition().getValue().equals(EXTENSION_STRUCTURE_DEFINITION_URL)) {
        extensions.add(structDef);
      } else if (isResource(structDef)) {
        resources.add(structDef);
      } else if (kind == StructureDefinitionKindCode.Value.PRIMITIVE_TYPE
          || kind == StructureDefinitionKindCode.Value.COMPLEX_TYPE) {
        datatypes.add(structDef);
      }
    }
    if (!extensions.isEmpty()) {
      addZipEntry(
          args.outputName + "_extensions.proto",
          generator.generateFileDescriptor(extensions),
          printer,
          zipOutputStream);
      args.additionalImports.add(
          args.directoryInSource + "/" + args.outputName + "_extensions.proto");
    }

    if (!datatypes.isEmpty()) {
      addZipEntry(
          "datatypes.proto", generator.generateFileDescriptor(datatypes), printer, zipOutputStream);
    }

    // TODO(b/244184211): Move Contained Resource logic into ProtoGenerator.java
    if (!resources.isEmpty()) {
      List<DescriptorProto> containedTypes = new ArrayList<>();
      // Note that in the case where there is a contained resource that is local to a proto set,
      // (the usual case), we need to define the ContainedResource proto in the same file as the
      // Bundle proto to avoid a circular dependency.  Since we need to define all other resources
      // before we can define ContainedResource, we defer printing the Bundle file until after
      // all other resources are generated, and after we've added in ContainedResource.
      FileDescriptorProto deferredBundleFile = null;
      for (StructureDefinition structDef : resources) {
        FileDescriptorProto fileProto =
            generator.generateFileDescriptor(ImmutableList.of(structDef), args.additionalImports);
        DescriptorProto type = fileProto.getMessageType(0);
        String filename = resourceNameToFileName(GeneratorUtils.getTypeName(structDef), generator);
        if (type.getName().equals("Bundle")) {
          deferredBundleFile = fileProto;
        } else {
          addZipEntry(filename, fileProto, printer, zipOutputStream);
        }
        if (!type.getOptions().getExtension(Annotations.isAbstractType)) {
          containedTypes.add(type);
        }
      }
      if (deferredBundleFile != null) {
        if (packageInfo.getLocalContainedResource()) {
          FileDescriptorProto.Builder fileBuilder =
              generator.addContainedResource(deferredBundleFile, containedTypes).toBuilder();
          String importRoot = args.directoryInSource;
          while (importRoot.contains("/../")) {
            // resolve foo/bar/baz/../../quux into foo/quux
            importRoot = importRoot.replaceAll("/[^/]*/\\.\\./", "/");
          }
          for (DescriptorProto type : containedTypes) {
            if (!type.getName().equals("Bundle")) {
              fileBuilder.addDependency(
                  new File(importRoot, resourceNameToFileName(type.getName(), generator))
                      .toString());
            }
          }
          addZipEntry(
              "bundle_and_contained_resource.proto", fileBuilder.build(), printer, zipOutputStream);
        } else {
          addZipEntry("bundle.proto", deferredBundleFile, printer, zipOutputStream);
        }
      }
    }
  }

  private void addZipEntry(
      String filename,
      FileDescriptorProto fileProto,
      ProtoFilePrinter printer,
      ZipOutputStream zipOutputStream)
      throws IOException {
    try {
      zipOutputStream.putNextEntry(new ZipEntry(filename));
      byte[] entryBytes = printer.print(maybeSortFile(fileProto)).getBytes(UTF_8);
      zipOutputStream.write(entryBytes, 0, entryBytes.length);
    } finally {
      zipOutputStream.closeEntry();
    }
  }

  String resourceNameToFileName(String resourceName, ProtoGenerator generator) {
    return CaseFormat.UPPER_CAMEL.to(
            CaseFormat.LOWER_UNDERSCORE,
            GeneratorUtils.resolveAcronyms(GeneratorUtils.toFieldTypeCase(resourceName)))
        + ".proto";
  }

  private FileDescriptorProto maybeSortFile(FileDescriptorProto proto) {
    if (args.sort) {
      return proto.toBuilder()
          .clearMessageType()
          .addAllMessageType(
              proto.getMessageTypeList().stream()
                  .sorted(
                      (a, b) -> {
                        boolean aIsPrimitive = AnnotationUtils.isPrimitiveType(a);
                        boolean bIsPrimitive = AnnotationUtils.isPrimitiveType(b);
                        if (aIsPrimitive != bIsPrimitive) {
                          return aIsPrimitive ? -1 : 1;
                        } else {
                          return a.getName().compareTo(b.getName());
                        }
                      })
                  .collect(Collectors.toList()))
          .build();
    }
    return proto;
  }

  private static boolean isResource(StructureDefinition definition) {
    // Despite being categorized as "Logical" rather than a "Resource",
    // MetadataResource is included here for historical reasons (and lack of a better place...)
    return definition.getKind().getValue() == StructureDefinitionKindCode.Value.RESOURCE
        || definition.getId().getValue().equals("MetadataResource");
  }

  public static void main(String[] argv) throws IOException, InvalidFhirException {
    // Each non-flag argument is assumed to be an input file.
    Args args = new Args();
    JCommander jcommander = new JCommander(args);
    try {
      jcommander.parse(argv);
    } catch (ParameterException exception) {
      System.err.printf("Invalid usage: %s\n", exception.getMessage());
      System.exit(1);
    }
    new ProtoGeneratorMain(args).run();
  }
}
